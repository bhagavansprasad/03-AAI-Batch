import os
import json
import asyncio
from typing import TypedDict, Optional, List, Dict, Any
from langgraph.graph import StateGraph, START, END
from fastmcp import Client
from lg_utility import save_graph_as_png
from debug_utils import (
    log_node_enter, log_node_exit, log_step, log_ok, log_warn,
    log_error, log_state
)

AGENT = "GIT-WRITE"

# ============================================================================
# STATE  â€” only what the write agent needs
# ============================================================================

class GitWriteAgentState(TypedDict):
    # â”€â”€ inputs (from Orchestrator) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    owner:               str
    repo:                str
    pull_number:         int
    review_comments:     Optional[Dict[str, Any]]    # structured review from LLM
    bugs:                Optional[List[Dict[str, Any]]]
    test_suggetions:     Optional[Dict[str, Any]]    # {test_framework, test_cases}
    jira_ticket_details: Optional[List[Dict[str, Any]]]

    # â”€â”€ outputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    comment_posted:      bool
    tests_committed:     bool
    pr_tagged:           bool

    # â”€â”€ internal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    client:              Optional[Any]


# ============================================================================
# HELPERS
# ============================================================================

async def call_mcp_tool(client, tool_name: str, arguments: dict) -> str:
    """Call a GitHub MCP tool and return raw response text."""
    log_step(AGENT, f"MCP call: {tool_name}")
    result       = await client.call_tool(tool_name, arguments)
    content_text = result.content[0].text
    log_step(AGENT, f"MCP response: {content_text[:200]}")
    return content_text


def _build_pr_comment(review: dict, jira_tickets: list) -> str:
    """Format LLM review + Jira links into a GitHub markdown comment."""
    lines = ["## ðŸ¤– Automated PR Review\n"]

    summary = review.get("summary", "")
    if summary:
        lines.append(f"### Summary\n{summary}\n")

    bugs = review.get("bugs", [])
    if bugs:
        lines.append("### ðŸ› Bugs Found\n")
        for b in bugs:
            sev   = b.get("severity", "?").upper()
            title = b.get("title", b.get("type", "?"))
            desc  = b.get("description", "")
            fix   = b.get("suggestion", "")
            lines.append(f"**[{sev}] {title}**")
            lines.append(f"> {desc}")
            if fix:
                lines.append(f"ðŸ’¡ *{fix}*")
            lines.append("")

    quality = review.get("quality_issues", [])
    if quality:
        lines.append("### âš ï¸ Code Quality Issues\n")
        for q in quality:
            lines.append(f"- {q}")
        lines.append("")

    security = review.get("security_issues", [])
    if security:
        lines.append("### ðŸ”’ Security Issues\n")
        for s in security:
            lines.append(f"- {s}")
        lines.append("")

    positive = review.get("positive_feedback", [])
    if positive:
        lines.append("### âœ… Positive Feedback\n")
        for p in positive:
            lines.append(f"- {p}")
        lines.append("")

    if jira_tickets:
        lines.append("### ðŸŽ« Jira Tickets Created\n")
        for t in jira_tickets:
            key   = t.get("ticket_key", "?")
            url   = t.get("ticket_url", "")
            sev   = t.get("severity", "?").upper()
            btype = t.get("bug_type", "?")
            lines.append(f"- [{key}]({url}) â€” [{sev}] {btype}")
        lines.append("")

    lines.append("---\n*Generated by PR Review Bot*")
    return "\n".join(lines)


def _build_test_file(test_data: dict) -> str:
    """Assemble all test cases into a single Python test file."""
    framework  = test_data.get("test_framework", "pytest")
    test_cases = test_data.get("test_cases", [])

    lines = [
        "# Auto-generated tests by PR Review Bot",
        f"# Framework: {framework}",
        "",
        "import pytest",
        "",
    ]
    for tc in test_cases:
        lines.append(f"# {tc.get('description', '')}")
        lines.append(f"# Covers: {tc.get('covers_bug', 'general')}")
        lines.append(tc.get("test_code", ""))
        lines.append("")

    return "\n".join(lines)


# ============================================================================
# NODES
# ============================================================================

# â”€â”€â”€ NODE 1 â€” init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def git_write_init_node(state: GitWriteAgentState) -> GitWriteAgentState:
    log_node_enter(AGENT, "GIT_WRITE_INIT", "reset outputs, log incoming data")

    state["comment_posted"]  = False
    state["tests_committed"] = False
    state["pr_tagged"]       = False
    state["client"]          = None

    log_step(AGENT, f"Target       : github.com/{state.get('owner')}/{state.get('repo')}  PR#{state.get('pull_number')}")
    log_step(AGENT, f"Bugs         : {len(state.get('bugs') or [])}")
    log_step(AGENT, f"Jira tickets : {len(state.get('jira_ticket_details') or [])}")
    tests = state.get("test_suggetions") or {}
    log_step(AGENT, f"Test cases   : {len(tests.get('test_cases', []) if isinstance(tests, dict) else [])}")

    log_node_exit(AGENT, "GIT_WRITE_INIT")
    return state


# â”€â”€â”€ NODE 2 â€” connect to GitHub MCP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def git_write_connect_mcp_node(state: GitWriteAgentState) -> GitWriteAgentState:
    log_node_enter(AGENT, "CONNECT_MCP", "open FastMCP client to GitHub server")

    mcp_url = os.getenv("GITHUB_MCP_SERVER_URL")
    log_step(AGENT, f"GITHUB_MCP_SERVER_URL = {mcp_url or '(NOT SET!)'}")

    if not mcp_url:
        log_error(AGENT, "GITHUB_MCP_SERVER_URL not set â€” all write operations will be skipped")
        log_node_exit(AGENT, "CONNECT_MCP")
        return state

    try:
        client = Client(mcp_url)
        await client.__aenter__()
        state["client"] = client
        log_ok(AGENT, "GitHub MCP client connected")
    except Exception as e:
        log_error(AGENT, f"Connection failed: {e}")

    log_node_exit(AGENT, "CONNECT_MCP")
    return state


# â”€â”€â”€ NODE 3 â€” post review comment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def git_post_comment_node(state: GitWriteAgentState) -> GitWriteAgentState:
    log_node_enter(AGENT, "POST_COMMENTS", "post formatted review comment to GitHub PR")

    client = state.get("client")
    if not client:
        log_warn(AGENT, "No MCP client â€” skipping")
        log_node_exit(AGENT, "POST_COMMENTS")
        return state

    review  = state.get("review_comments") or {}
    tickets = state.get("jira_ticket_details") or []

    if not review:
        log_warn(AGENT, "review_comments is empty â€” nothing to post")
        log_node_exit(AGENT, "POST_COMMENTS")
        return state

    comment_body = _build_pr_comment(review, tickets)
    log_step(AGENT, f"Comment body: {len(comment_body)} chars")
    log_step(AGENT, f"Preview:\n{comment_body[:300]}\n...")

    # GITHUB_ADD_PULL_REQUEST_REVIEW_COMMENT is not in this MCP tool set.
    # Writing the review as a markdown file committed to the repo instead.
    review_file = f".bot-reviews/pr_{state['pull_number']}_review.md"
    log_step(AGENT, f"Writing review to: {review_file}")
    try:
        await call_mcp_tool(client, "GITHUB_CREATE_OR_UPDATE_FILE_CONTENTS", {
            "owner":   state["owner"],
            "repo":    state["repo"],
            "path":    review_file,
            "message": f"bot: add automated review for PR #{state['pull_number']}",
            "content": comment_body,
        })
        state["comment_posted"] = True
        log_ok(AGENT, f"Review written to {review_file}")
    except Exception as e:
        log_error(AGENT, f"Failed to write review file: {e}")

    log_node_exit(AGENT, "POST_COMMENTS")
    return state


# â”€â”€â”€ NODE 4 â€” commit test file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def git_commit_tests_node(state: GitWriteAgentState) -> GitWriteAgentState:
    log_node_enter(AGENT, "COMMIT_TESTS", "commit auto-generated test file to PR branch")

    client = state.get("client")
    if not client:
        log_warn(AGENT, "No MCP client â€” skipping")
        log_node_exit(AGENT, "COMMIT_TESTS")
        return state

    tests      = state.get("test_suggetions") or {}
    test_cases = tests.get("test_cases", []) if isinstance(tests, dict) else []

    if not test_cases:
        log_warn(AGENT, "No test cases â€” skipping commit")
        log_node_exit(AGENT, "COMMIT_TESTS")
        return state

    file_content = _build_test_file(tests)
    file_path    = f"tests/test_pr_{state['pull_number']}_autobot.py"
    commit_msg   = f"bot: add auto-generated tests for PR #{state['pull_number']}"

    log_step(AGENT, f"File      : {file_path}")
    log_step(AGENT, f"Commit msg: {commit_msg}")
    log_step(AGENT, f"Test cases: {len(test_cases)}")
    log_step(AGENT, f"File size : {len(file_content)} chars")
    for i, tc in enumerate(test_cases, 1):
        log_step(AGENT, f"  Test {i}: {tc.get('test_name', '?')} â€” {tc.get('description', '')[:60]}")

    try:
        await call_mcp_tool(client, "GITHUB_CREATE_OR_UPDATE_FILE_CONTENTS", {
            "owner":   state["owner"],
            "repo":    state["repo"],
            "path":    file_path,
            "message": commit_msg,
            "content": file_content,
        })
        state["tests_committed"] = True
        log_ok(AGENT, f"Test file committed: {file_path}")
    except Exception as e:
        log_error(AGENT, f"Failed to commit tests: {e}")

    log_node_exit(AGENT, "COMMIT_TESTS")
    return state


# â”€â”€â”€ NODE 5 â€” tag PR with labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def git_tag_pr_node(state: GitWriteAgentState) -> GitWriteAgentState:
    log_node_enter(AGENT, "TAG_PR", "apply severity label + bot-reviewed to PR")

    client = state.get("client")
    if not client:
        log_warn(AGENT, "No MCP client â€” skipping")
        log_node_exit(AGENT, "TAG_PR")
        return state

    bugs       = state.get("bugs") or []
    severities = [b.get("severity", "low").lower() for b in bugs]

    if "high" in severities:
        severity_label = "bot-review: high-severity"
    elif "medium" in severities:
        severity_label = "bot-review: medium-severity"
    else:
        severity_label = "bot-review: low-severity"

    labels = [severity_label, "bot-reviewed"]
    log_step(AGENT, f"Severity breakdown : {severities}")
    log_step(AGENT, f"Labels to apply    : {labels}")

    # GITHUB_ADD_LABELS_TO_ISSUE is not in this MCP tool set.
    # Writing a tag summary file to the repo instead.
    tag_file = f".bot-reviews/pr_{state['pull_number']}_tags.md"
    tag_content = f"# Bot Review Tags\n\nPR #{state['pull_number']}\n\nLabels:\n" + "\n".join(f"- {l}" for l in labels)
    log_step(AGENT, f"Writing tag summary to: {tag_file}")
    try:
        await call_mcp_tool(client, "GITHUB_CREATE_OR_UPDATE_FILE_CONTENTS", {
            "owner":   state["owner"],
            "repo":    state["repo"],
            "path":    tag_file,
            "message": f"bot: tag PR #{state['pull_number']} as {severity_label}",
            "content": tag_content,
        })
        state["pr_tagged"] = True
        log_ok(AGENT, f"Tag summary written to {tag_file}")
    except Exception as e:
        log_error(AGENT, f"Failed to write tag file: {e}")

    # â”€â”€ final summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    log_state(AGENT, {
        "owner":           state.get("owner"),
        "repo":            state.get("repo"),
        "PR#":             state.get("pull_number"),
        "comment_posted":  state["comment_posted"],
        "tests_committed": state["tests_committed"],
        "pr_tagged":       state["pr_tagged"],
    }, label="GIT-WRITE final summary")

    log_node_exit(AGENT, "TAG_PR")
    return state


# ============================================================================
# GRAPH
# ============================================================================

def graph_Builder():
    graph = StateGraph(GitWriteAgentState)

    graph.add_node("GIT_WRITE_INIT", git_write_init_node)        # async
    graph.add_node("CONNECT_MCP",    git_write_connect_mcp_node) # async
    graph.add_node("POST_COMMENTS",  git_post_comment_node)      # async
    graph.add_node("COMMIT_TESTS",   git_commit_tests_node)      # async
    graph.add_node("TAG_PR",         git_tag_pr_node)            # async

    graph.add_edge(START,            "GIT_WRITE_INIT")
    graph.add_edge("GIT_WRITE_INIT", "CONNECT_MCP")
    graph.add_edge("CONNECT_MCP",    "POST_COMMENTS")
    graph.add_edge("POST_COMMENTS",  "COMMIT_TESTS")
    graph.add_edge("COMMIT_TESTS",   "TAG_PR")
    graph.add_edge("TAG_PR",         END)

    compiled = graph.compile()
    save_graph_as_png(compiled, __file__)
    return compiled


git_Write_graph = graph_Builder()


# ============================================================================
# MAIN â€” standalone test
# ============================================================================

async def _test():
    test_state = GitWriteAgentState(
        owner="promptlyaig",
        repo="issue-tracker",
        pull_number=1,
        review_comments={
            "summary": "PR has a pagination bug and incomplete implementation.",
            "bugs": [{"severity": "medium", "title": "Pagination off-by-one",
                      "description": "start index wrong", "suggestion": "use (page-1)*per_page"}],
            "quality_issues": ["Missing docstrings"],
            "security_issues": [],
            "positive_feedback": ["Good test structure"],
        },
        bugs=[{"severity": "medium", "type": "pagination_error",
               "description": "off-by-one", "location": "app.py:42",
               "suggestion": "fix index"}],
        test_suggetions={
            "test_framework": "pytest",
            "test_cases": [{"test_name": "test_paginate",
                            "description": "test pagination logic",
                            "test_code": "def test_paginate():\n    assert (1-1)*5 == 0",
                            "covers_bug": "pagination_error"}],
        },
        jira_ticket_details=[{"ticket_key": "PROM-321",
                               "ticket_url": "https://promptlyai.atlassian.net/browse/PROM-321",
                               "severity": "medium", "bug_type": "pagination_error"}],
    )
    result = await git_Write_graph.ainvoke(test_state)
    print(f"\ncomment_posted={result['comment_posted']}  "
          f"tests_committed={result['tests_committed']}  "
          f"pr_tagged={result['pr_tagged']}")


def main():
    asyncio.run(_test())

if __name__ == "__main__":
    main()
